#!/bin/bash -u
# Copyright Thales Services 2014
# Author C. VAN FRACHEM

# This files contains reusable, project-independant shell functions 

# return the OS type: linux or mac. 
# Usage OS=$(lmc_get_os)


#this function is a filter used to drop output in quiet mode
function stdout() { if [ "${quiet:-}" != "true" ];  then cat; else true; fi ;}
#this function is a filter used to redirect standard output from a command to error output
function stderr() { cat >&2 ;}

function debugTimestamp() { date +%Y%m%d%H%M%S ;}

#this function is a filter used to redirect standard output from a command to common shells log flow
function commonsLogger() {
	if [ -z "${COMMONS_LOG_FILE:-}" ] ; then 
		stdout
	else 
		caller=$(basename "$0" 2>/dev/null)
		if [ "$caller" == "" ] ; then
			caller=">$0"
		fi
		sed "s#^#$(debugTimestamp) @ ${caller} : #g" >> "${COMMONS_LOG_FILE}"
	fi 
}

#this function sends outputonly  to COMMONS_LOG_FILE (if defined) OR STDOUT if not defined

function silentLog() { echo "$*" | lmcLogger; }
function unquietableLog() { quiet="false" log $@ ; }

#this function sends output both to stdout AND  to LMC_LOG_FILE (if defined)
# option -n can be provided to avoid addition of final carriage return
# option -- can be provided to request log processing from stdin
function log() {
	echoOpt="" 
	if [ "${1:-}" == "-n" ] ; then
		echoOpt="-n"
		shift
	fi
	if [ "${1:-}" == "--" ] ; then
		if ! [ -z "${COMMONS_LOG_FILE}" ] ; then
			tee >(commonsLogger) | stdout
		else
			commonsLogger
		fi
	else
		echo ${echoOpt} "$*" | stdout ;
		# the following 'if' is intended to avoid duplicate logging to stdout in case we do not have a lmc log file
		if ! [ -z "${COMMONS_LOG_FILE:-}" ] ; then silentLog "$*"; fi
	fi
}



function errecho() { 
	echo "$*" >&2 ;
	if ! [ -z "${COMMONS_LOG_FILE:-}" ] ; then silentLog "$*"; fi
}

function warn() { errecho "WARNING reported by '$(basename "${0:-}")': $*" ;}
function error() { errecho "ERROR reported by '$(basename "${0:-}")': $*" ;}
function fatal() { errecho "FATAL ERROR in '$(basename "${0:-}")': ${*:-generic error}" ; exit -1 ;}


function debug() { echo "$*" | commonsLogger ; }

#
# Returns the platform you are running on: mac or linux.
# As of today supports only linux or mac/Darwin.
# 
# Arguments : none
# Usage     : platform=$(getPlatform)
#
function getPlatform() {
	platform='unknown'
	unamestr=`uname`
	if [[ "$unamestr" == 'Linux' ]]; then
		platform='linux'
	elif [[ "$unamestr" == 'Darwin' ]]; then
		platform='mac'
	fi
	echo $platform
}

# generic wait loop 
function tryLoop() {
	maxOverallWaitInSeconds=$1
	waitBetweenRetriesInSeconds=$2
	command=$3
	waitingForObjectDescription=$4
	startingTimestamp=`date +%s` 
	let retryLimitTimestamp=startingTimestamp+maxOverallWaitInSeconds
	succeeded=0
	currentTimestamp=${startingTimestamp}
	eval "$command" && return 0
	firstSleep=1
	while [ ${currentTimestamp} -lt ${retryLimitTimestamp} ] ; do 
		let remainingWait=retryLimitTimestamp-currentTimestamp
		[ $firstSleep -ne 1 ] && errecho "Waiting for ${waitingForObjectDescription} (will wait ${remainingWait} seconds max)..."
		firstSleep=0
		sleep ${waitBetweenRetriesInSeconds}
		eval "$command" && succeeded=1 && break;
		currentTimestamp=`date +%s`
	done
	if [ $succeeded -eq 0 ] && [ $firstSleep -ne 1 ]; then
		warn "Timeout without success for ${waitingForObjectDescription}"
	fi
	[ $succeeded -ne 0 ]
}


# list directory
function check_and_return_unique_file_from_pattern() {
	namePattern=$1
	lsOptions=${2:-}
	#echo SEARCHING files=\$(ls ${lsOptions} "$namePattern" )
	files="$(ls ${lsOptions} $namePattern )"
	if [ -z "${files}" ] ; then fatal "no file matching required pattern ${namePattern} !" ;fi
			
	nbDirs="$(echo "$files" | wc -l)"
	
	if [ ${nbDirs} -gt 1 ] ;then fatal "there should be only one file matching pattern ${namePattern} !"  ;fi
	# this is the return value (echoed to function stdout)
	echo "$files"
}

# returns the hostname part in a string of the form hostname:port
# the function resists to the absence of :port part
# the second argument (optional) is a default value
function hostFromHostColumnPort () {
	toParse="$1"
	defaultHost="${2:-}"
	host=${toParse%%:*}
	echo "${host:-${defaultHost}}"
}

# returns the port part in a string of the form hostname:port
# the function resists to the absence of :port part
# the second argument (optional) is a default value
function portFromHostColumnPort () {
	toParse="$1"
	defaultPort="${2:-}"
	port=${toParse##*:}
	if [ "$port" == "$toParse" ]; then 
		# on gere le cas ou ":xxx" est absent
		echo "${defaultPort}"
	else
		# on gere le cas nominal mais aussi le cas ou ':' est present mais avec rien derriere
		echo "${port:-${defaultPort}}"
	fi
}

# function sending each of its parameters as a line to stdout
function convertParametersToStdoutLines() {
	while [ $# -gt 0 ] ; do
		echo "$1"
		shift
	done
}

function bashArrayToLines() {
	for line in "$@" ; do
		echo "$line"
	done
}

#function producing a representation of provided list
# the produced format is of the form : [ "value1", "value2", ... , "valuen" ]
# the input list can be provided through the parameters, or through lines on stdin by specifying parameter '--'
function listToJsonString() {
	if [ "${1:-}" == "--" ]; then
		input="$(cat)"
	else
		input=$(bashArrayToLines "$@")
	fi
	if [ "$input" == "" ] ; then
		echo '[ ]'
	else
		sed -e 's/\(.*\)/"\1"/' <(echo "$input")  | sed -n -e :a -e '$p;N;s/\n/, /' -e ta -e q | sed 's/\(.*\)/[ \1 ]/'
	fi
}

logVarDefaultPrefix="        "
logVarDefaultNamePadding=30
#function to dump a variable name and its value
function logVar() {
	varName="$1"
	leftPrefix="${2:-${logVarDefaultPrefix}}"
	namePadding="${3:-${logVarDefaultNamePadding}}"
	log "${leftPrefix}$(rightPadding ${namePadding} ${varName}) = \"`eval 'echo ${'$varName'}'`\""
}


#function to dump an array variable name and its values
function logArrayVar() {
	varName="$1"
	leftPrefix="${2:-${logVarDefaultPrefix}}"
	namePadding="${3:-${logVarDefaultNamePadding}}"
	log "${leftPrefix}$(rightPadding ${namePadding} ${varName}) = `eval 'listToJsonString ${'$varName'[@]}'`"
}


function waitForTcpPortAvailability() {
	host=$1
	port=$2
	sleepBetweenTrials=${3:-3}
	maxOverallWaitInSeconds=${4:-60}
	tryLoop $sleepBetweenTrials $maxOverallWaitInSeconds "nc -z $1 $2" "Tcp port $1:$2 availability"
}

# function to wait for an answer without HTTP error code, from a remote HTTP
function waitForHttpGetAvailable () {
	httpUrl="$1"
	sleepStepInSeconds="$2"
	maxOverallWaitInSeconds="$3"
	command='curl -s -o/dev/null --noproxy '*' --retry 0 -XGET "'${httpUrl}'"'
	tryloop $maxOverallWaitInSeconds $sleepStepInSeconds "$command" "HTTP URL '${httpUrl}'"
}

function waitForPingSuccess() {
 hostToWait="$1"
 maxWaitInSeconds=${2:-5}
 log -n "Waiting for PING answer from '${hostToWait}'... "
( ping -W ${maxWaitInSeconds} -c 1 -q ${hostToWait} > /dev/null  ) || fatal "unable to ping server '${hostToWait}'"
 log "OK"
}

function waitForSshSuccess() {
	# usage : waitForSshSuccess [user]@<host> [<maxWaitInSeconds>] [ -c 'remote command to launch']
 hostToWait="$1"
 command="echo """""
 maxWaitInSeconds=10
 shift
 while [ $# -gt 0 ] ; do

 	if [ "$1" == -c ]; then
 		command="$2"
 		commandLog=" using remote command '$command'"
 		shift 2
 	else
		maxWaitInSeconds=$2
	fi
done
 log -n "Waiting for SSH sucess on '${hostToWait}'${commandLog:-}... "
( ssh ${hostToWait} -o ConnectTimeout=${maxWaitInSeconds} $command > /dev/null  ) || fatal "unable to ssh on server '${hostToWait}'"
 log "OK"
}

#returns local IP addresses, one by line (including loopback localhost interface)
function localIpV4Addresses() {
	platform=$(getPlatform)
	if [ "$platform" == "mac" ]; then
		ifconfig | awk '/inet / {print $2}'
	else
		ip -4 -o addr show | sed -n 's/.*\binet\s\+\([^ ]\+\)\s.*/\1/p' | sed 's#/.*##g'
	fi
}

#for each argument received (or line from stdin, if "--" parameter is provided
	# returns the corresponding V4 IP (or the input, if already an IP)
function resolveIpV4Host() {
	if [ "${1:-}" == "--" ]; then
		input="$(cat)"
	else
		input=$*
	fi
	for hostnameOrIp in $input ; do
		if ( echo ${hostnameOrIp} | grep -q '^[a-zA-Z]') ; then
			# we have a hostname
			python -c "import socket;print socket.gethostbyname('$hostnameOrIp');"
		else
			# we have a host ip
			echo ${hostnameOrIp}
		fi
	done 
}

# function which return value indicates if at least one word matches
# in two lists,  with separators beeing either newlines or whitespace
function listsHaveNonEmptyIntersection() {
	aList=$1
	bList=$2
	intersection=$(comm -12 <(echo "$aList" | sed 's/\s\+/\n/g' | sort -u) <(echo "$bList" | sed 's/\s\+/\n/g'| sort -u))
	[ "$intersection" != "" ]
}

# function which adds spaces in order to pad the provided lines to match at least provided length
# if only one parameter is provided, stdin is used as source. If more than one, the parameters are processed instead
defaultPaddingChar=' '
function rightPadding() {
	paddingChar=$defaultPaddingChar
	if [ "${1:-}" == "--padding-char" ]; then
		paddingChar=${2:-.}
		shift 2
	fi
	desiredLength=${1}
	if [ $# == 1 ] ; then
		sed -e :a -e 's/^.\{1,'${desiredLength}'\}$/& /;ta'
	else
		shift
		while [ $# -gt 0 ] ; do
			echo "$1" | sed -e :a -e "s/^.\{1,${desiredLength}\}$/&${paddingChar}/;ta"
			shift
		done
	fi
}

# function that checks if one of the ip addresses of local host is included in the provided list
# hostnames in the list are resolved to IPV4 names automatically, and port number prefixes are ignored
# (such as myhost:3000,otherhost:18000). separators can be spaces or commas
function currentHostIsInHostList() {
	ipsToScan=$(echo "${1:-}" | tr "," " " | sed 's/:[0-9]*//g' | resolveIpV4Host -- )
    listsHaveNonEmptyIntersection "${ipsToScan}" "$(localIpV4Addresses)"
}


function queryJsonConf() {
    jsonQuery=$1
    jsonData=${2:-}
    if [ "${jsonData}" == "" ]; then
    	if [ "${JSON_CONFIG:-}" == "" ]; then
    		error "JSON_CONFIG variable is not define to provide a default json configuration source file for 'queryJsonConf' function."
    		return 1
    	fi
        dataSource="file '$JSON_CONFIG'."
        jsonData=$(cat "$JSON_CONFIG")
    else
        dataSource="string '$jsonData'"
    fi
    echo "$jsonData" | jq --compact-output "$jsonQuery" || error "Could not execute json query '$jsonQuery' on ${dataSource}."
}

function getJsonConfValue () {
    jsonPath=$1
    jsonData=${2:-}
    errorString="Could not retrieve string matching json path '$jsonPath."
    answer=$(queryJsonConf "$jsonPath" "$jsonData") || error "${errorString}"
    if [ "$answer" == "null" ]; then
        error "$errorString"
    else
        echo "$answer" | sed 's/^"\(.*\)"$/\1/g'
    fi
}

function getJsonConfArrayValues () {
    jsonPath=$1
    jsonData=${2:-}
    errorString="Could not retrieve string matching json path '$jsonPath."
    answer=$(queryJsonConf "$jsonPath" "$jsonData") || error "${errorString}"
    if [ "$answer" == "null" ]; then
        error "$errorString"
    else
        echo "$answer" | sed 's/^"\(.*\)"$/\1/g'
    fi
}

function jinja2TemplateInstanciation () {
	templateFile=$1
	[ -f "$templateFile" ] || fatal "Not able to find jinja2 template '${templateFile}'."
	python -c "import jinja2" || fatal "Python and python-jinja2 must be available in order to use 'jinja2TemplateInstanciation' function." 
	containerDir=$(dirname "$templateFile")
	templateName=$(basename "$templateFile")
	python -c "import jinja2; import os ; env=jinja2.Environment(loader=jinja2.FileSystemLoader(\"${containerDir}\")); env.globals.update(os.environ); template=env.get_template(\"${templateName}\");print template.render();"
}




# function to replace all symbolic links in the provided 
function getRealPath() {
	pathToCorrect=$1
	if [ -d "$pathToCorrect" ]; then
		( cd "$pathToCorrect" ; pwd -P )
	else
		error "function getRealPath not implemented for something else than an existing directory ; '$pathToCorrect' was provided."
		echo "InvalidPathProvidedToFunction_getRealPath:$pathToCorrect"
	fi
}

#function that prompts the user with a yes/no question (provided)
#first keystroke is the user answer
#case is ignored
# default behaviour if return is pressed is "No", except if parameter 2
# indicated "Y" as the default answer
function userConfirmationByYKey() {
	question=$1
	defaultAnswer=${2:-N}
	read -p "$question " -n 1 answer
	echo ""
	if [ "$answer" == "" ]; then answer=$defaultAnswer; fi
	[ "$answer" == "y" ] || [ "$answer" == "Y" ]
}

function absolutePath() {
	echo $(cd $(dirname "$1"); pwd)/$(basename "$1")
}

#filter which get rids of lines beginning with # (with whitespaces bedore #)
function uncomment() {
	grep -v '^\s*#' $@
}

# provide normalized printout for terse service status
function terseStatusReport() {
	serviceName=$1
	status=$2
	report=$(rightPadding --padding-char . 40 "$serviceName")$status
	log "$report"
}

